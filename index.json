[{"body":"Gossip, at a very high level, is a specification for an API that allows different bots to talk to each other in a simple and predictable way. The specification is flexible and customizable to allow for developers to customize implementations to suit their needs while also ensuring standards to allow bots of any caliber to work with each other. The specification is loosely inspired by SCIM.\nGossip allows bot developers to:\n Create an arbitrary network of bots capable of exchanging information Pull information from other clients in a network (“lookups”) Push information to other clients in a network (“notifies”) Implement and expect a common set of extensible schemas Extend or create schemas for application-specific use cases, such as IPC  The Gossip specification follows a federated model where clients (generally bots) will directly communicate with each other. While clients are generally bots, persistent datastores known as “brokers” may be present in any given Gossip network.\n","link":"https://gossip.rest/docs/fundamentals/","title":"Fundamentals"},{"body":"Welcome to the documentation for Gossip!\nGossip is an API specification to allow bots to communicate with each other. A typical use case for this would be to have multiple specialised bots all feed into one central system for cases/infractions, Gossip aims to make an open protocol to make standard implementations for this so any bot can participate in the system.\n","link":"https://gossip.rest/docs/","title":"Welcome!"},{"body":"Clients are, fundamentally, HTTP servers that allow data exchange between nodes in a Gossip network.\nGossip clients shall have four operating capabilities:\n Receiving Lookups from clients (inbound GET) Sending Lookups to clients (outbound GET) Receiving Notifies from clients (inbound POST/PUT) Sending Notifies to clients (outbound POST/PUT)  Clients are encouraged to support all above modes, however a client may only implement those that are necessary to the client’s operation. Of specific note, however, is that a client that supports receiving Notifies MUST additionally support receiving Lookups.\n","link":"https://gossip.rest/docs/fundamentals/clients/","title":"Clients"},{"body":"Tier I - Core Attributes All Schemas contain a core set of required data known as Core Attributes. Any client capable of reporting information of this schema type MUST include all Core Attributes. Core Attributes MAY be null depending on the type of data, but the field values must be present.\nTier II - Extended Attributes Schemas may contain an extended set of in-specification data values. This data MAY be provided by clients if available, but clients SHALL NOT expect this data to be present. Optional Extended Data MAY be null or missing entirely.\nTier III - Client-Specific Attributes Schemas may contain Client-Specific Attributes, which are to be considered an extension of a Schema. Client-Specific Attributes MAY be provided by clients if available. Clients SHOULD be aware of extra data although processing of this data is not required. These attributes are not defined in the specification.\n","link":"https://gossip.rest/docs/fundamentals/schemas/","title":"Schemas"},{"body":"Within this section you'll find the documentation for the resources which can be accessed and modified through Gossip.\n","link":"https://gossip.rest/docs/resources/","title":"Resources"},{"body":"Authentication There are two modes of authentication for routes in Gossip:\n Header-based authentication using the Authorization header. No authentication; anonymous requests.  Header-based Authentication For authenticated endpoints the client should pass an Authorization header with their bearer token:\nAuthorization: Bearer b3c98d3f The format of that Authorization token its left to the implementor\nRate Limits Implementors are free to implement rate limits as needed, the following headers should be sent when a rate limit is active\nX-RateLimit-Limit Limit on number of calls for the current endpoint X-RateLimit-Remaining Number of calls remaining for the current endpoint X-RateLimit-Reset Unix epoch timestamp in milliseconds for next reset X-RateLimit-Retry-After Only sent after rate limit is active, milliseconds until the client should retry\nWhen a client exceeds the limit, the server MUST send a 429 Too Many Requests status code alongwith a X-RateLimit-Retry-After header\nRoutes The basic route format for API routes is /{namespace}/{version}/{topic}/{resource}. The version is namespace specific. If the namespace is gossip then the current active version is v1.\ngossip is a reserved namespace, used for gossip standards. Implementors are free to implement custom routes on their own namespace\nBoth GET and POST should be implemented, POST is used to create a new event, GET to get all events your key has access to (and can be filtered further by the event schema)\nMiscellaneous Routes GET /details This is not a versioned endpoint and should not be prefixed with /{version}  This endpoint details information about the server including it's capabilities and API version.\nReturn Body:\n   Field Type Description     version string The server's API version.   capabilities json A capabilities object detailing the server's capabilities.   meta json Any extra data the server wants to give about itself.    Example Body:\n1{ 2 \u0026#34;version\u0026#34;:\u0026#34;1\u0026#34;, 3 \u0026#34;capabilities\u0026#34;:{ 4 \u0026#34;endpoints\u0026#34;: [ 5 \u0026#34;/gossip/v1/cases\u0026#34;, 6 \u0026#34;/myBot/v1/counters\u0026#34; 7 ] 8 }, 9 \u0026#34;meta\u0026#34;:{ 10 \u0026#34;host\u0026#34;:{ 11 \u0026#34;language\u0026#34;:\u0026#34;Python\u0026#34;, 12 \u0026#34;library\u0026#34;:\u0026#34;Gossipy-Server\u0026#34;, 13 \u0026#34;os\u0026#34;:\u0026#34;Linux/Debian\u0026#34; 14 } 15 } 16} Standard routes Routes made standard and implemented inside the gossip namespace are documented in Standard Routes\n","link":"https://gossip.rest/docs/resources/api-reference/","title":"API Reference"},{"body":"Cases POST /gossip/v1/cases This endpoint notifies the server of a new case\nRequest Body:\n   Field Type. Description     guild snowflake Guild ID where the case took place.   user snowflake User ID where the action was taken.   actioner snowflake User ID that created the case. Might be bot ID if it was automated.   action case_action Type of action taken.   duration long. Milliseconds for duration. 0 if permanent   reason string. Reason for action, might be empty    Where case_action is one of (BAN, KICK, MUTE, WARN, UNMUTE, UNBAN, NOTE)\nExample Body:\n1{ 2 \u0026#34;data\u0026#34;:{ 3 \u0026#34;guild\u0026#34;:810932869862129664, 4 \u0026#34;user\u0026#34;: 297045071457681409, 5 \u0026#34;actioner\u0026#34;: 427045071457681409, 6 \u0026#34;action\u0026#34;: \u0026#34;BAN\u0026#34;, 7 \u0026#34;duration\u0026#34;: 3600, 8 \u0026#34;reason\u0026#34;: \u0026#34;Spamming all channels with rickrolls\u0026#34; 9 } 10} GET /gossip/v1/cases This endpoint gets all cases you have access to, with optional filters and pagination\nRequest Body:\n   Field Type. Description     user snowflake Filter for a specific user.   guild snowflake Filter for a specific guild.   actioner snowflake Filter for a specific actioner.   page_size int Max page size, implementors can set their own max   page int Page to return, starts on 1    None, one or multiple filters can be set\nExample request:\n/gossip/v1/cases?user=1234567\u0026amp;page=2\nExample return:\n1{ 2 \u0026#34;page_size\u0026#34;: 200, 3 \u0026#34;current_page\u0026#34;: 1, 4 \u0026#34;total_pages\u0026#34;: 20 5 \u0026#34;data\u0026#34;: [ 6 { 7 \u0026#34;guild\u0026#34;:810932869862129664, 8 \u0026#34;user\u0026#34;: 297045071457681409, 9 \u0026#34;actioner\u0026#34;: 427045071457681409, 10 \u0026#34;action\u0026#34;: \u0026#34;BAN\u0026#34;, 11 \u0026#34;duration\u0026#34;: 3600, 12 \u0026#34;reason\u0026#34;: \u0026#34;Spamming all channels with rickrolls\u0026#34; 13 } 14 ] 15} ","link":"https://gossip.rest/docs/resources/standard-routes/","title":"Standard Routes"},{"body":"Gossip Gossip is an API specification to allow bots to communicate with each other. A typical use case for this would be to have multiple specialised bots all feed into one central system for cases/infractions, Gossip aims to make an open protocol to make standard implementations for this so any bot can participate in the system.\nGossip is a work in progress, things might break or be undocumented. Tread with caution!  Read the DocsView on GitHub\n","link":"https://gossip.rest/","title":"Gossip"}]